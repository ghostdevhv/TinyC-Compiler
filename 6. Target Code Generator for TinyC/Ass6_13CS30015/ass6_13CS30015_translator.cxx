#include "ass6_13CS30015_translator.h"
#include "y.tab.h"
extern int yydebug;
extern char * yytext;

extern void yyerror(const char *);
extern int yylex();


int tempvarCount = 0;

int func_count = 0;

symbol_table * glob_sym_table = new symbol_table("ST (global)");
symbol_table * curr_sym_table = new symbol_table();

// map <string, int> uniqueLabels;
// vector <string> strLabels;

// stack <string> arg_stack;

// the list of all quads to be generated by the program
quad_array quad_arr;

// Type Definitions

symbol_type::symbol_type() {}

// constructor with type_declare b
symbol_type::symbol_type(type_declare b)
{
    type_d = b;
    size = 1;
    next = NULL;
    if(b <= type_dec_DOUBLE)
    {
        size = this->getSize();
    }
}

// copy constructor
symbol_type::symbol_type(const symbol_type &t)
{
    symbol_type * ptr1 = (symbol_type *)this;
    symbol_type * ptr2 = (symbol_type *)&t;
    ptr1->type_d = ptr2->type_d;
    ptr1->size = ptr2->size;
    while(ptr2 != NULL)
    {
        ptr1->type_d = ptr2->type_d;
        ptr1->size = ptr2->size;
        ptr2 = ptr2->next;
        if(ptr2 == NULL) ptr1->next = NULL;
        else ptr1->next = new symbol_type();
        ptr1 = ptr1->next;
    }
    assert(ptr1 == NULL && ptr2 == NULL);
}

// recursively get size of current object
int symbol_type::getSize()
{
    switch(type_d) {
        case (type_dec_INT):
            return SIZE_OF_INT;
        case (type_dec_CHAR):
            return SIZE_OF_CHAR;
        case (type_dec_VOID):
            return SIZE_OF_VOID;
        case (type_dec_DOUBLE):
            return SIZE_OF_DOUBLE;
        case (type_dec_FUNC):
            return SIZE_OF_FUNC;
        case (type_dec_PTR):
            return SIZE_OF_PTR;
        case (type_dec_BOOL):
            return SIZE_OF_BOOL;
        case (type_dec_ARR):
            return size * next->getSize();
        default:
            yyerror("Unknown type");
            exit(1);
    }
}

// To print the current type of the symbol entry
void symbol_type::print() {
    switch(type_d) {
        case (type_dec_INT):
            printf("int");
            return;
        case (type_dec_DOUBLE):
            printf("double");
            return;
        case (type_dec_CHAR):
            printf("char");
            return;
        case (type_dec_VOID):
            printf("void");
            return;
        case (type_dec_BOOL):
            printf("bool");
            return;
        case (type_dec_PTR):
            printf("ptr(");
            next->print();
            printf(")");
            return;
        case (type_dec_FUNC):
            printf("func");
            return;
        case (type_dec_ARR):
            printf("array(%d, ", size);
            next->print();
            printf(")");
            return;
        default:
            printf("Error ! Unknown type found !\n");
            exit(-1);
    }
}

// check if two types t1 and t2 are equal or not
bool areEqual(symbol_type * t1, symbol_type * t2)
{
    symbol_type * ptr1 = t1;
    symbol_type * ptr2 = t2;
    while(ptr1 != NULL and ptr2 != NULL) 
    {
        if(ptr1->type_d != ptr2->type_d) return false;
        ptr1 = ptr1->next;
        ptr2 = ptr2->next;
    }
    if(ptr1 == NULL && ptr2 == NULL) return true;
    else 
    {
        yyerror("Incompatible types");
        exit(1);
    }
    return false;
}

// Symbol Entry Structure Definitions

symbol_entry::symbol_entry(string s) 
{
    nestedTable = NULL;
    was_Init = false;
    scope = s;
}

// print all the fields of the entry of symbol table
void symbol_entry::print() 
{
    printf("%10s\t", this->name.c_str());
    printf("\t");
    this->type->print();
    printf("\t");
    if(this->was_Init) 
    {
        switch(this->type->type_d) 
        {
            case (type_dec_INT):
                printf("%5d", this->init.intVal);
                break;
            case (type_dec_CHAR):
                printf("%5c", this->init.charVal);
                break;
            case (type_dec_DOUBLE):
                printf("%5.3lf", this->init.doubleVal);
                break;
            default:
                printf("Invalid Type");
        }
    }
    else printf(" NULL ");
    
    printf("\t");
    printf("%5d", this->size);
    printf("\t");
    printf("%5d", this->offset);
    printf("\t");
    printf("%10s", this->scope.c_str());
    printf("\t");
    if(this->nestedTable != NULL) printf("%20s\t", this->nestedTable->table_name.c_str());
    else printf("%15s\t", "NULL");
    puts("");
}

// default constructor
symbol_table::symbol_table() 
{
    offset = 0;
}

// constructor with the name of symbol table
symbol_table::symbol_table(string s) 
{
    table_name = s;
    offset = 0;
}

// search a string in the symbol table
// if found return the pointer to the entry
// else create a new entry for current string and return its pointer
symbol_entry * symbol_table::lookUp(string name)
{
    for(int i = 0; i < (int)entries.size(); ++i) 
    {
        if(entries[i]->name.length() != 0 && name == entries[i]->name) 
        {
            return entries[i];
        }
    }
    symbol_entry * new_entry = new symbol_entry();
    new_entry->name = name;
    entries.push_back(new_entry);
    return new_entry;
}

// generate a temporary variable of given type
symbol_entry * symbol_table::genTemp(symbol_type * type)
{
    symbol_entry * new_entry = new symbol_entry("temp");
    char tmp[10];
    // give this variable a unique name
    sprintf(tmp, "t%03d", tempvarCount);
    ++tempvarCount;
    new_entry->name = tmp;
    new_entry->type = type;
    int newenSZ = 0;
    switch(type->type_d) {
        case (type_dec_INT):
            newenSZ = SIZE_OF_INT;
            break;
        case (type_dec_CHAR):
            newenSZ = SIZE_OF_CHAR;
            break;
        case (type_dec_DOUBLE):
            newenSZ = SIZE_OF_DOUBLE;
            break;
        case (type_dec_PTR):
            newenSZ = SIZE_OF_PTR;
            break;
        default:
            newenSZ = 0;
    }
    // update size and offset
    new_entry->size = newenSZ;
    new_entry->offset = offset;
    offset += newenSZ;
    // add it to the list of entries
    entries.push_back(new_entry);
    return new_entry;
}

// Update the type and size of an existing entry
void symbol_table::update(symbol_entry * sy, symbol_type * t, int _size)
{
    sy->type = t;
    sy->size = _size;
    sy->offset = offset;
    offset += sy->size;
    if(t->type_d == type_dec_FUNC) sy->scope = "global";
}

// Update the initial value of a symbol entry
void symbol_table::update(symbol_entry * sy, init_val init)
{
    sy->init = init;
    sy->was_Init = true;
}

// check if a variable or a particular entry is present in a symbol table or not
bool symbol_table::isPresent(string s_name)
{
    for(int i = 0; i < (int)entries.size(); ++i) 
    {
        if(entries[i]->name.length() != 0 && s_name == entries[i]->name) 
        {
            return true;
        }
    }
    return false;
}

// print all the entries of the symbol table
void symbol_table::print()
{
    printf("%s:\n", table_name.c_str());
    printf("Name\t\tType\t\tInit Val\t\tSize\t\tOffset\t\tScope\t\tNested Table\n");
    for(int i = 0; i < (int)entries.size(); ++i) {
        entries[i]->print();
    }
    puts("");
}

// quad function definitions
// constructors of quad entries
quad::quad(string res, string s1, opcode_declare o, string s2) : result(res), arg1(s1), op(o), arg2(s2) {}

quad::quad(string res, int n, opcode_declare o) : result(res), arg2(""), op(o)
{
    char buff[10];
    sprintf(buff, "%d", n);
    arg1=buff;
}

quad::quad(string res, double d, opcode_declare o) : result(res), arg2(""), op(o)
{
    char buff[10];
    sprintf(buff, "%lf", d);
    arg1 = buff;
}

quad::quad(string res, char c, opcode_declare o) : result(res), arg2(""), op(o)
{
    char buff[10];
    sprintf(buff, "%d", (int)c);
    arg1 = buff;
}

// Set the result field of the current symbol 
void quad::setTarget(int addr) {
    char tmp[10];
    sprintf(tmp, "%d", addr);
    string stmp(tmp);
    this->result = stmp;
}

// add the quad to the list
void quad_array::emit(quad q)
{
    // add the quad and increase the next instruction
    this->vec.push_back(q);
    this->nxt_instr++;
}

// print the quad entry according to the opcode
void quad::print()
{
    switch(op) {
        case(opcode_dec_PLUS):
            printf("%s = %s + %s\n", result.c_str(), arg1.c_str(), arg2.c_str());
            break;
        case(opcode_dec_MINUS):
            printf("%s = %s - %s\n", result.c_str(), arg1.c_str(), arg2.c_str());
            break;
        case(opcode_dec_MULT):
            printf("%s = %s * %s\n", result.c_str(), arg1.c_str(), arg2.c_str());
            break;
        case(opcode_dec_DIVIDE):
            printf("%s = %s / %s\n", result.c_str(), arg1.c_str(), arg2.c_str());
            break;
        case(opcode_dec_MODULO):
            printf("%s = %s %% %s\n", result.c_str(), arg1.c_str(), arg2.c_str());
            break;
        case(opcode_dec_UNARY_MINUS):
            printf("%s = -%s\n", result.c_str(), arg1.c_str());
            break;
        case(opcode_dec_ASSIGN):
            printf("%s = %s\n", result.c_str(), arg1.c_str());
            break;
        case(opcode_dec_IF_EXP):
            printf("if (%s) goto %s\n", arg1.c_str(), result.c_str());
            break;
        case(opcode_dec_IF_NOT_EXP):
            printf("ifFalse (%s) goto %s\n", arg1.c_str(), result.c_str());
            break;
        case(opcode_dec_LESS_THAN):
            printf("if (%s < %s) goto %s\n", arg1.c_str(), arg2.c_str(), result.c_str());
            break;
        case(opcode_dec_LESS_OR_EQUAL):
            printf("if (%s <= %s) goto %s\n", arg1.c_str(), arg2.c_str(), result.c_str());
            break;
        case(opcode_dec_GREATER_THAN):
            printf("if (%s > %s) goto %s\n", arg1.c_str(), arg2.c_str(), result.c_str());
            break;
        case(opcode_dec_GRTER_OR_EQUAL):
            printf("if (%s >= %s) goto %s\n", arg1.c_str(), arg2.c_str(), result.c_str());
            break;
        case(opcode_dec_EQUAL):
            printf("if (%s == %s) goto %s\n", arg1.c_str(), arg2.c_str(), result.c_str());
            break;
        case(opcode_dec_NOT_EQUAL):
            printf("if (%s != %s) goto %s\n", arg1.c_str(), arg2.c_str(), result.c_str());
            break;
        case(opcode_dec_INT2DBL):
            printf("%s = int2dbl(%s)\n", result.c_str(), arg1.c_str());
            break;
        case(opcode_dec_DBL2INT):
            printf("%s = dbl2int(%s)\n", result.c_str(), arg1.c_str());
            break;
        case(opcode_dec_INT2CHAR):
            printf("%s = int2char(%s)\n", result.c_str(), arg1.c_str());
            break;
        case(opcode_dec_CHAR2INT):
            printf("%s = char2int(%s)\n", result.c_str(), arg1.c_str());
            break;
        case(opcode_dec_L_VAL_AT):
            printf("* %s = %s\n", result.c_str(), arg1.c_str());
            break;
        case(opcode_dec_R_VAL_AT):
            printf("%s = * %s\n", result.c_str(), arg1.c_str());
            break;
        case(opcode_dec_L_INDEX):
            printf("%s[%s] = %s\n", result.c_str(), arg1.c_str(), arg2.c_str());
            break;
        case(opcode_dec_R_INDEX):
            printf("%s = %s[%s]\n", result.c_str(), arg1.c_str(), arg2.c_str());
            break;
        case(opcode_dec_ADDRESS):
            printf("%s = & %s\n", result.c_str(), arg1.c_str());
            break;
        case(opcode_dec_PARAM):
            printf("param %s\n", result.c_str());
            break;
        case(opcode_dec_GOTO):
            printf("goto %s\n", result.c_str());
            break;
        case(opcode_dec_CALL):
            printf("%s = call %s, %s\n", result.c_str(), arg1.c_str(), arg2.c_str());
            break;
        case(opcode_dec_RETURN):
            printf("return\n");
            break;
        case(opcode_dec_RETURN_VAL):
            printf("return %s\n", result.c_str());
            break;
        case(opcode_dec_BITWISE_COMPLEMENT):
            printf("%s = ~ %s\n", result.c_str(), arg1.c_str());
            break;
        case(opcode_dec_LEFT_SHIFT):
            printf("%s = %s << %s\n", result.c_str(), arg1.c_str(), arg2.c_str());
            break;
        case(opcode_dec_RIGHT_SHIFT):
            printf("%s = %s >> %s\n", result.c_str(), arg1.c_str(), arg2.c_str());
            break;
        case(opcode_dec_BITWISE_AND):
            printf("%s = %s & %s\n", result.c_str(), arg1.c_str(), arg2.c_str());
            break;
        case(opcode_dec_BITWISE_XOR):
            printf("%s = %s ^ %s\n", result.c_str(), arg1.c_str(), arg2.c_str());
            break;
        case(opcode_dec_BITWISE_OR):
            printf("%s = %s | %s\n", result.c_str(), arg1.c_str(), arg2.c_str());
            break;
        // case(opcode_dec_LOGICAL_OR):
        //     printf("%s = %s || %s\n", result.c_str(), arg1.c_str(), arg2.c_str());
        //     break;
        // case(opcode_dec_LOGICAL_AND):
        //     printf("%s = %s && %s\n", result.c_str(), arg1.c_str(), arg2.c_str());
        //     break;   
        case(opcode_dec_FUNC_START):
            printf("%s Starts\n", result.c_str());
            break;
        case(opcode_dec_FUNC_END):
            printf("%s Ends\n", result.c_str());
            break;
        default:
            printf("Error ! Unknown opcode_declare.\n");
            exit(-1);
    }
}

// list_node constructors
list_node::list_node() : next(NULL) {}

list_node::list_node(int idx) : Idx(idx), next(NULL) {}

// List constructors
list_nodes::list_nodes()
{
    head = tail = NULL;
}

list_nodes::list_nodes(int idx)
{
    head = new list_node(idx);
    tail = head;
}

// print the list (for debugging purpose)
void list_nodes::print()
{
    list_node * ptr = head;
    while(ptr != NULL) 
    {
        printf("%d ", ptr->Idx);
        ptr = ptr->next;
    }
    printf("\n");
}

// delete the allocated memory
void list_nodes::clear()
{
    list_node * ptr = head, * tobedeletePtr;
    while(ptr != NULL) 
    {
        tobedeletePtr = ptr;
        ptr = ptr->next;
        delete tobedeletePtr;
    }
    head = NULL;
    tail = NULL;
}

// merge two lists i.e. concatenating list l2 after l1 and returning l1
list_nodes * mergeList(list_nodes * l1, list_nodes * l2)
{
    // check if one of the list is NULL
    if(l1 == NULL || l1->head == NULL) return l2;
    if(l2 == NULL || l2->head == NULL) return l1;
    l1->tail->next = l2->head;
    l1->tail = l2->tail;
    return l1;
}

// convert int to string
string i2s(int n)
{
    char tmp[10];
    sprintf(tmp, "%d", n);
    return tmp;
}

// Backpatch the list with given address
void backPatch(list_nodes * &p, int addr) 
{
    if(p != NULL && p->head != NULL) 
    {
        list_node * ptr = p->head;
        while(ptr != NULL)
        {
            quad_arr.vec[ptr->Idx].setTarget(addr); 
            ptr = ptr->next;
        }
        p->clear();
        p = NULL;
    }
}

// Print all the quads generated
void printAllQuads() 
{
    for(int i = 0; i < (int)quad_arr.vec.size(); ++i) 
    {
        printf("%3d. ", i); 
        quad_arr.vec[i].print();
    }
}

// check the type of two expressions
// if they are not equal convert them accordingly
// for assignment operation, e2 must be converted to e1 type 
// otherwise, they should be converted to higher data type
bool typeCheck(expression_type * e1, expression_type * e2, bool isAssignment)
{
   // check = 0;
    if(!areEqual(e1->type, e2->type)) 
    {
        expression_type * e3 = new expression_type();
        // convert lower type to higher
        if(!isAssignment && e1->type->type_d < e2->type->type_d)
        {
            // Special case for bool to int conversion
            if(e1->type->type_d == type_dec_BOOL && e2->type->type_d == type_dec_INT) 
            {
                convBool2Int(e1);
                return true;
            } 
            e3->loc = curr_sym_table->genTemp(new symbol_type(*(e2->type)));
            e3->type = e3->type;
            // generate a quad with opcode for conversion
            if(e1->type->type_d == type_dec_INT && e2->type->type_d == type_dec_DOUBLE) 
            {
                quad_arr.emit(quad(e3->loc->name, e1->loc->name,opcode_dec_INT2DBL,""));

            } 
            else if(e1->type->type_d == type_dec_INT && e2->type->type_d == type_dec_CHAR) 
            {
                quad_arr.emit(quad(e3->loc->name, e1->loc->name,opcode_dec_INT2CHAR,""));

            } 
            else if(e1->type->type_d == type_dec_CHAR && e2->type->type_d == type_dec_INT) 
            {
                quad_arr.emit(quad(e3->loc->name, e1->loc->name,opcode_dec_CHAR2INT,""));

            } 
            else if(e1->type->type_d == type_dec_DOUBLE && e2->type->type_d == type_dec_INT) 
            {
                quad_arr.emit(quad(e3->loc->name, e1->loc->name,opcode_dec_DBL2INT,""));

            } 
            else return false;

            e1->loc = e3->loc;
        } 
        else 
        {
            if(e2->type->type_d == type_dec_BOOL && e1->type->type_d == type_dec_INT) 
            {
                convBool2Int(e2);
                return true;
            } 
            e3->loc = curr_sym_table->genTemp(new symbol_type(*(e1->type)));
            e3->type = e3->type;
            // generate a quad with opcode for conversion
            if(e1->type->type_d == type_dec_INT && e2->type->type_d == type_dec_DOUBLE) 
            {
                quad_arr.emit(quad(e3->loc->name, e2->loc->name,opcode_dec_DBL2INT,""));

            } 
            else if(e1->type->type_d == type_dec_INT && e2->type->type_d == type_dec_CHAR) 
            {
                quad_arr.emit(quad(e3->loc->name, e2->loc->name,opcode_dec_CHAR2INT,""));

            } 
            else if(e1->type->type_d == type_dec_CHAR && e2->type->type_d == type_dec_INT) 
            {
                quad_arr.emit(quad(e3->loc->name, e2->loc->name,opcode_dec_INT2CHAR,""));

            } 
            else if(e1->type->type_d == type_dec_DOUBLE && e2->type->type_d == type_dec_INT) 
            {
                quad_arr.emit(quad(e3->loc->name, e2->loc->name,opcode_dec_INT2DBL,""));

            } 
            else return false;

            e2->loc = e3->loc; 
        }
    }
    return true;
}

// convert an expression to bool type
void conv2Bool(expression_type * e) 
{
    if(e->type->type_d != type_dec_BOOL) 
    {
        // create true list and false list
        e->falseList = new list_nodes(quad_arr.nxt_instr);
        quad_arr.emit(quad("", e->loc->name, opcode_dec_EQUAL,"0"));
        e->trueList = new list_nodes(quad_arr.nxt_instr);
        quad_arr.emit(quad("","",opcode_dec_GOTO, ""));
    }
}

// convert bool to int
void convBool2Int(expression_type * b) 
{
    if(b->type->type_d == type_dec_BOOL) 
    {
        expression_type * e = new expression_type();
        e->loc = curr_sym_table->genTemp(new symbol_type(type_dec_INT));
        e->type = e->loc->type;
        backPatch(b->trueList, quad_arr.nxt_instr);
        quad_arr.emit(quad(e->loc->name, "1", opcode_dec_ASSIGN, ""));
        backPatch(b->falseList, quad_arr.nxt_instr);
        quad_arr.emit(quad(e->loc->name, "0", opcode_dec_ASSIGN, ""));
        b->loc = e->loc;
        b->type = e->type;
    }
}

// check the types of parameter
bool paramTypeCheck(expression_type * e1, expression_type * e2) 
{
    if((e1->type->type_d == type_dec_ARR || e1->type->type_d == type_dec_PTR) && 
       (e2->type->type_d == type_dec_ARR || e2->type->type_d == type_dec_PTR)) 
    {
        return true;
    }
    return typeCheck(e1, e2, true);
}

// check the parameters of a function with the arguments
bool checkParams(expression_type e, vector <expression_type *> * args) 
{
    int paramNO = 0;
    vector <symbol_entry *> & v = e.loc->nestedTable->entries;
    for(int i = 1; i < (int)v.size(); ++i) 
    {
        if(v[i]->scope != "param") continue;
        if(paramNO >= (int)args->size()) return false;
        expression_type e1;
        e1.type = v[i]->type;
        expression_type * e2 = (*args)[paramNO];
        ++paramNO;
        if(!paramTypeCheck(&e1, e2)) return false;
    }
    return paramNO == (int)args->size();
}

